/*
 * Problem 12
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 * The first ten terms would be:
 *
 *   1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *  10: 1,2,5,10
 *  15: 1,3,5,15
 *  21: 1,3,7,21
 *  28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 */

#include <sys/queue.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct fact
{
	int		val;
	int		cnt;
	STAILQ_ENTRY(fact)	next;
} fact_t;

typedef struct pfacts
{
	STAILQ_HEAD(, fact)	head;
} pfacts_t;

static pfacts_t *pf_merge(pfacts_t *, pfacts_t *);
static pfacts_t *prime_decomp(int);
static void pf_free(pfacts_t *);
static int next_prime(int);
static int ndivisor(pfacts_t *);

#define TARGET_NDIVISOR		500

int
main(int argc, char *argv[])
{
	pfacts_t *pf1, *pf2, *mpf;
	int index, nd;

	index = 1;
	pf1 = prime_decomp(index);
	while (1) {
		index++;
		pf2 = prime_decomp(index);
		mpf = pf_merge(pf1, pf2);
		nd = ndivisor(mpf);
		if (nd >= TARGET_NDIVISOR)
			break;
		pf_free(mpf);
		pf_free(pf1);
		pf1 = pf2;
	}
	pf_free(mpf);
	pf_free(pf1);
	pf_free(pf2);
	printf("%d\n", (index*(index-1))/2);

	return 0;
}

/*
 * merge two pfact_t
 */
static pfacts_t *
pf_merge(pfacts_t *pf1, pfacts_t *pf2)
{
	pfacts_t *mpf;
	fact_t *f1, *f2, *f;
	mpf = (pfacts_t *)malloc(sizeof(pfacts_t));
	STAILQ_INIT(&mpf->head);
	f1 = STAILQ_FIRST(&pf1->head);
	f2 = STAILQ_FIRST(&pf2->head);
	while (f1 && f2) {
		f = (fact_t *)malloc(sizeof(fact_t));
		if (f1->val == f2->val) {
			f->val = f1->val;
			f->cnt = f1->cnt + f2->cnt;
			f1 = STAILQ_NEXT(f1, next);
			f2 = STAILQ_NEXT(f2, next);
		} else if (f1->val < f2->val) {
			f->val = f1->val;
			f->cnt = f1->cnt;
			f1 = STAILQ_NEXT(f1, next);
		} else {
			f->val = f2->val;
			f->cnt = f2->cnt;
			f2 = STAILQ_NEXT(f2, next);
		}
		STAILQ_INSERT_TAIL(&mpf->head, f, next);
	}
	/* copy rest of f1 of f2 */
	while (f1) {
		f = (fact_t *)malloc(sizeof(fact_t));
		f->val = f1->val;
		f->cnt = f1->cnt;
		STAILQ_INSERT_TAIL(&mpf->head, f, next);
		f1 = STAILQ_NEXT(f1, next);
	}
	while (f2) {
		f = (fact_t *)malloc(sizeof(fact_t));
		f->val = f2->val;
		f->cnt = f2->cnt;
		STAILQ_INSERT_TAIL(&mpf->head, f, next);
		f2 = STAILQ_NEXT(f2, next);
	}
	/* we remove first 2 divisor */
	f = STAILQ_FIRST(&mpf->head);
	f->cnt--;
	return mpf;
}

/*
 * prime factor decomposition of num
 */
static pfacts_t *
prime_decomp(int num)
{
	pfacts_t *pf;
	fact_t *f;
	int val;

	pf = (pfacts_t *)malloc(sizeof(pfacts_t));
	STAILQ_INIT(&pf->head);
	val = 1;
	while (num > 1) {
		val = next_prime(val);
		if (num % val == 0) {
			f = (fact_t *)malloc(sizeof(fact_t));
			f->val = val;
			f->cnt = 0;
			while (num % val == 0) {
				num = num / val;
				f->cnt++;
			}
			STAILQ_INSERT_TAIL(&pf->head, f, next);
		}
	}
	return pf;
}

/*
 * free data allocated in prime_decomp()
 */
static void
pf_free(pfacts_t *pf)
{
	fact_t *f;
	while (!STAILQ_EMPTY(&pf->head)) {
		f = STAILQ_FIRST(&pf->head);
		STAILQ_REMOVE_HEAD(&pf->head, next);
		free(f);
	}
	free(pf);
}

/*
 * found prime number that next of num
 */
static int
next_prime(int num)
{
	int i;
	while (1) {
		num++;
		for (i = 2; i < num; i++)
			if (num % i == 0)
				break;
		if (i == num)
			/* found prime */
			break;
	}
	return num;
}

/*
 * number of divisors
 */
static int
ndivisor(pfacts_t *pf)
{
	int nd = 1;
	fact_t *f;
	STAILQ_FOREACH(f, &pf->head, next) {
		nd *= f->cnt + 1;
	}
	return nd;
}

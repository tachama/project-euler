/*
 * Consider all integer combinations of a ** b for 2 <= a <= 5 and 2 <= b <= 5:
 *
 *   2**2=4, 2**3=8, 2**4=16, 2**5=32
 *   3**2=9, 3**3=27, 3**4=81, 3**5=243
 *   4**2=16, 4**3=64, 4**4=256, 4**5=1024
 *   5**2=25, 5**3=125, 5**4=625, 5**5=3125
 * If they are then placed in numerical order, with any repeats removed, we get
 * the following sequence of 15 distinct terms:
 *
 *   4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
 *
 * How many distinct terms are in the sequence generated by a ** b for
 * 2 <= a <= 100 and 2 <= b <= 100?
 */

#include <err.h>
#include <stdio.h>
#include <string.h>

#define NUM_MAX  100
/* i keep a ** b as primes factors */
typedef struct {
	int avail;  /* 1: available, 0:unavailable */
	int prime[NUM_MAX];
} num_t;

/* global variable */
num_t num[NUM_MAX][NUM_MAX];  /* access num[a][b] */

static void convert_num(num_t *, int, int);
static int compnum(num_t *, num_t *);
static int next_prime(int);

int
main(int argc, char *argv[])
{
	int a, b, a2, b2;
	int ndist;

	/* calculate all numbers */
	memset(num, 0, sizeof(num));
	for (a = 2; a <= NUM_MAX; a++) {
		for (b = 2; b <= NUM_MAX; b++)
			convert_num(&num[a-1][b-1], a, b);
	}

	/* filter duplicated num */
	for (a = 2; a <= NUM_MAX; a++) {
		for (b = 2; b <= NUM_MAX; b++) {
			if (!num[a-1][b-1].avail)
				/* ignore unavailables */
				continue;
			for (a2 = 2; a2 <= NUM_MAX; a2++) {
				for (b2 = 2; b2 <= NUM_MAX; b2++) {
					if ((a != a2 || b != b2)
					    && num[a2-1][b2-1].avail
					    && compnum(&num[a-1][b-1], &num[a2-1][b2-1]) == 0) {
						/* disable duplicated num */
						num[a2-1][b2-1].avail = 0;
					}
				}
			}
		}
	}

	/* count distinct number */
	ndist = 0;
	for (a = 2; a <= NUM_MAX; a++) {
		for (b = 2; b <= NUM_MAX; b++) {
			if (num[a-1][b-1].avail)
				ndist++;
		}
	}
	printf("%d\n", ndist);
	return 0;
}

static void
convert_num(num_t *num, int a, int b)
{
	int i, n = 1;

	while (a > 1) {
		n = next_prime(n);
		while (a % n == 0) {
			num->prime[n-1] += 1;
			a = a / n;
		}
	}
	for (i = 0; i < NUM_MAX; i++)
		num->prime[i] *= b;
	num->avail = 1;
}

static int
compnum(num_t *n1, num_t *n2)
{
	return memcmp(n1->prime, n2->prime, sizeof(int) * NUM_MAX);
}

static int
next_prime(int num)
{
	int i;
	do {
		num++;
		for (i = 2; i < num; i++) {
			if (num % i == 0)
				break;
		}
	} while (i != num);
	/* overflow check */
	if (num > NUM_MAX)
		errx(1, "invalid in next_prime()");
	return num;
}
